#!/usr/bin/env python3
import cv2
import json
import argparse
import numpy as np
from time import ctime
from colorama import Back, Fore, Style
from functools import partial 
from math import sqrt

def process_image(image, data, height, width, mask_color):
    """
    Process the image given by the camera to create the mask.
    """
    # Extract color limits from the JSON data
    bmin, bmax = data['limits']['B']['min'], data['limits']['B']['max']
    gmin, gmax = data['limits']['G']['min'], data['limits']['G']['max']
    rmin, rmax = data['limits']['R']['min'], data['limits']['R']['max']

    # Create a mask based on color limits
    mask = cv2.inRange(image, (bmin, gmin, rmin), (bmax, gmax, rmax))

    green_mask = np.zeros((height, width, 3), np.uint8)
    green_mask[mask > 0] = mask_color

    mask_image = cv2.add(green_mask, image)

    return mask_image, green_mask

def get_connected_components(image):
    """
    Get connected components of binary image.
    """
    # Convert to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # Threshold to binary image
    _, binary_image = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    # Find connected components
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(binary_image, connectivity=4)
    return num_labels, labels, stats, centroids

def mouse_callback(event, x, y, flags, *userdata, image_canvas, drawing_data):
    """
    Mouse callback function.
    """
    if event == cv2.EVENT_LBUTTONDOWN:
        drawing_data['pencil_down'] = True
        print(Fore.BLUE + 'Pencil down set to True' + Fore.RESET)
    elif event == cv2.EVENT_LBUTTONUP:
        drawing_data['pencil_down'] = False
        print(Fore.RED + 'Pencil down released' + Fore.RESET)

    if drawing_data['pencil_down'] == True:
        cv2.line(image_canvas, (drawing_data['previous_x'], drawing_data['previous_y']), (x, y), drawing_data['color'], drawing_data['size'])

    drawing_data['previous_x'] = x
    drawing_data['previous_y'] = y

def main():
    parser = argparse.ArgumentParser(description='Definition of ' + Fore.BLUE + 'test ' + Fore.RESET + 'mode')
    parser.add_argument('-j', '--json', type=str, required=True, help='Full path to' + Fore.YELLOW + ' json ' + Fore.RESET + 'file.')
    parser.add_argument('-mc', '--mask_color', type=str, choices=['green', 'red', 'blue'], required=False,
                        help='Choose the color of the mask. Ex: Type ' + Fore.RED + ' red ' + Fore.RESET +
                             'to represent: [' + Fore.RED + '255' + Fore.RESET + ',' + Fore.GREEN + '0' + Fore.RESET + ',' + Fore.BLUE + '0' + Fore.RESET + ']')
    # ... (other argument definitions)

    args = vars(parser.parse_args())

    print('Welcome to the drawing game!')
    # ... (print instructions)

    # Initialize drawing data
    drawing_data = {'pencil_down': False, 'previous_x': 0, 'previous_y': 0, 'color': (0, 0, 0), 'size': 1}

    # Initial setup
    capture = cv2.VideoCapture(0)

    if args['mask_color']:
        mask_color = {'green': (0, 255, 0), 'red': (0, 0, 255), 'blue': (255, 0, 0)}.get(args['mask_color'], (0, 255, 0))
    else:
        mask_color = (0, 255, 0)

    cv2.namedWindow('Canvas Draw')

    _, image = capture.read()  # get an image from the camera
    height, width, channels = image.shape

    if args['use_mouse']:
        cv2.namedWindow('Canvas Draw')
        drawing_data = {'pencil_down': False, 'previous_x': 0, 'previous_y': 0, 'color': (0, 0, 0), 'size': 1}
        cv2.setMouseCallback("Canvas Draw", partial(mouse_callback, image_canvas=image_canvas, drawing_data=drawing_data))
    else:
        drawing_data = {'pencil_down': False, 'last_point': None, 'color': (0, 0, 0), 'size': 5}

    # ... (rest of the code)

if __name__ == '__main__':
    main()
